#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
from pathlib import Path
import re

base = Path("./data")
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"

# fp = "exact_kite_dyn=bornholdt_beta=0.12568738973509125_T=200.pkl"
# fp = "exact_kite_dyn=bornholdt_beta=0.23708107265108683_T=200.pkl"
fp = "exact_kite_dyn=sis_beta=9.122104355448496_T=200.pkl"
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"
# fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=1000.pkl"
# fp = "exact_small_tree_dyn=ising_beta=0.9001444450539172_T=200.pkl"

n_samples = int(re.findall("T=\d+", fp)[0].split("=")[1])


# fp = "exact_recursive_tree_4_beta=0.567_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=1_matching=0.7_beta=0.4272728243801874_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=5_matching=0.9_beta=0.4115334169153415_T=200.pkl"
# fp = "exact_circle_beta=0.567_T=200.pkl"
from exact_utils import fit_curve
df = pd.read_pickle(base / Path(fp))
f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
ndf = fit_curve(df, f, offset = True)
#+end_src

#+RESULTS:
#+begin_example
/tmp/ipykernel_46728/3983444258.py:27: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
/tmp/ipykernel_46728/3983444258.py:27: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
0.75/tmp/ipykernel_46728/3983444258.py:27: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
0.95000000000000011.05/tmp/ipykernel_46728/3983444258.py:27: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
/tmp/ipykernel_46728/3983444258.py:27: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
#+end_example




#+begin_src jupyter-python
target = 1 - row.mag
rowj = df[df.mag.round(2) == round(target,2)].iloc[0]

rowj = df.iloc[1]
print(rowj.mag, row.mag)
for mmi, mii in zip(row.mi.T, rowj.mi.T):
    print((mmi - mii).sum())

print(row.mag, rowj.mag)
rowj = df.iloc[1]
[ax[0].plot(mi, color = c) for mi, c in zip(rowj.mi.T, co)]
[ax[0].plot(mi - mmi, color = c) for mmi, mi, c in zip(row.mi.T, df.mi[df.mag == 1- row.mag].T, co)]

#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
0.15000000000000002 0.55
72.79499180908402
72.794991809084
21.929570582871953
104.91054726193892
21.92957058287196
16.537037310989373
16.537037310989373
88.02755738710033
103.0568935464924
94.20502946645624
0.55 0.15000000000000002
#+end_example
: []
:END:
Time plots with graph
#+begin_src jupyter-python
from utils import ccolors
row = df.iloc[1]
g = df.attrs["settings"].g
n = len(row.mi.T)
co = ccolors(n)
fig, ax = plt.subplots(ncols = 2, sharey = 0, sharex = 0)
[ax[0].plot(mi, color = c) for mi, c in zip(row.mi.T, co)]

ax[0].set_title(f"M(S) = {row.mag.round(2)}")
ax[0].format(
    yscale = "log",
    xscale = "log",
    xlabel = "Time(t)",
    ylabel = "$I(s_i ; S^t)$"
             )
g = nx.convert_node_labels_to_integers(g)
# pos = nx.forceatlas2_layout(g, scaling = 3)
pos = nx.kamada_kawai_layout(g)
nx.draw(g,pos, ax = ax[1], node_color = co, with_labels = True)
ax[1].axis("square")
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_46728/3907501757.py:21: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 616 :height 318
[[file:./.ob-jupyter/63f34c56c8b14442893012dab05aa726b7ce9e1b.png]]
:END:
# plot imi as function of tipping distance
#+begin_src jupyter-python
from utils import ccolors
imi = np.stack(ndf.imi)
mag = ndf.mag.unique()


imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g
# imi = np.argsort(imi, axis = -1)

degs = dict(g.degree())
n = len(imi.T)
c = ccolors(n)

%matplotlib inline
fig, ax = plt.subplots(ncols = 2, share = 0)#subplot_kw = dict(projection = '3d'))
for node, deg in degs.items():
    d = np.ones(n) * deg
    x, y, z = mag[:-1], imi[:, node], d
    ax[0].plot(x, y, color = c[node], marker = 'o')
# ax.scatter(mag[:-1], imi[:-1])
ax[0].format(
    yscale = "symlog",
)
nx.draw(g, ax = ax[1], node_color = c)
ax[1].axis("equal")
fig.show()

from matplotlib.pyplot import Line2D

# h = [
#     Line2D([], [], label = round(m, 1),  marker = 'o', linestyle = 'none',color = ci) for ci, m in zip(c, mag)
# ]
# ax.legend(handles = h, ncols = 1, loc = 'r')

#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_46728/3593237613.py:27: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 547 :height 282
[[file:./.ob-jupyter/ceab5762dca5c3b890f77bf70156583d9724ef8e.png]]
:END:

     0.85,  0.95,  1.05])


#+begin_src jupyter-python
from sklearn.preprocessing import minmax_scale
from utils import ccolors
imi = np.stack(ndf.imi)
h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

fig, axs = plt.subplots(nrows = 2,
                        ncols = n,
                        share = 1,
                        span = "row",
                        # spany = "row",
                        # height_ratios = [0.5, 1],
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
for ax, axj,  t in zip(axs[0,:], axs[1,:], targets):
    idx = np.where(mag.round(1) == t)[0][0]
    s = imi[idx]
    # s = minmax_scale(s)
    s /= s.max()
    for node, (ci, x, si) in enumerate(zip(c, pos.values(), s)):
        ax.scatter(*x, s = si*600, color = ci)
        axj.plot(df.mi.iloc[idx][:, node], color = ci)
    # nx.draw_networkx_nodes(g, pos, ax = ax, node_size = s * 100)
    # nx.draw_networkx_edges(g, pos, ax = ax, node_size = 0)

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")
    p = ndf.p0.iloc[idx]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    ax.set_title(f"{tit:.2f}",
                 )

axs[0, :].format(fontsize = fs,
                 )

fig.suptitle("System Stability\nFractions of nodes in +1")
axs[0,0].format(
    abc = 1,
    abc_kw = dict(text = "a"))

axs[1,0].format(
    abc = 1,
    abc_kw = dict(text = "b"))

axs[1,:].format(xlabel = "Time(t)",
                yscale = "log",
                # xscale = "log",
                fontsize = fs,
                )
yl = "$I(s_i : S^t)$"
axs[1,0].set_ylabel(yl, fontsize = fs)
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]
fig.savefig(f"./figures/{dyn}_kite_graph.pdf")
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 2089 :height 1120
[[file:./.ob-jupyter/a3c4e7279d00447c9e5748cbf3e9aeae2f05d68d.png]]
:END:


#+begin_src jupyter-python
p0 = ndf.p0.iloc[-1]
fig, ax = plt.subplots()
ax.plot(p0)
ax.format()
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
: 0.6211330462076126
: /tmp/ipykernel_1047557/2375806911.py:5: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 296 :height 282
[[file:./.ob-jupyter/d26c11af9bb12bba1e6e4c220bc5083cfe97c19d.png]]
:END:



#+begin_src jupyter-python
# G = nx.florentine_families_graph()
G = df.attrs["settings"].g
print(G.nodes())
# print(nx.adjacency_matrix(G))
# print(list(G.neighbors(12)))
#+end_src

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


#+begin_src jupyter-python
from utils import ccolors
mag = df.mag.unique()
n = mag.size

c = ccolors(n-1)
imi = np.stack(ndf.imi)
asy = np.stack(ndf.coeffs)[..., -1]
fig, ax = plt.subplots()
for x, y, ci in zip(asy[:-1].T, imi[:-1].T, c):
    ax.scatter(x,y, color = c)

ax.format(
    yscale = "log",
    xscale = "log"
)
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_46728/1884721076.py:16: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 322 :height 282
[[file:./.ob-jupyter/51c81875bfd269f5806468a6369d2eee9c7854a6.png]]
:END:

#+begin_src jupyter-python
print(df.attrs["settings"].g)
print(df.mag)
mi = df.mi.iloc[3]
fig, ax = plt.subplots()
ax.plot(mi)
ax.format()
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
Graph named 'Krackhardt Kite Social Network' with 10 nodes and 18 edges
0     0.05
1     0.15
2     0.25
3     0.35
4     0.45
5     0.55
6     0.65
7     0.75
8     0.85
9     0.95
10    1.05
11   -1.00
Name: mag, dtype: float64
/tmp/ipykernel_46728/4272061681.py:7: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
#+end_example
#+attr_org: :width 295 :height 282
[[file:./.ob-jupyter/509424bb73c5f36cb9d2ae8689152f7ba4f3368c.png]]
:END:

#+begin_src jupyter-python
fig, ax = plt.subplots()
for ci, x, y in zip(c, imi[:n + 1].T, offset[:n + 1].T):
    # y = np.ones(x.size) * y
    # y += np.random.randn() * 0.2
    # ax.scatter(x, y, c = c)
    ax.plot(x, y, color = 'k', zorder = 0, markercolor = ci,
            marker = 'o', markeredgecolor = 'none',
            linestyle = 'none')
    x1 = x[:-1]; x2 = x[1:]
    y1 = y[:-1]; y2 = y[1:]
    dx = x2 - x1; dy = y2 - y1

    ax.quiver(x1, y1, dx, dy,
            scale_units='xy',
            angles='xy',
            scale= 1.04,
            alpha = 1, zorder = 0,
            )
    ax.invert_yaxis()


ax.format()
fig.show()

#+end_src


#+name: imi vs asymp
#+begin_src jupyter-python
imi = np.stack(ndf.imi)
offset = np.stack(ndf.coeffs)[..., -1]
c = ccolors(len(imi[:-1]))
fig, ax = plt.subplots(ncols = 2, sharex = 0, sharey = 0)
for ci, x, y in zip(c, imi[:-1].T, offset[:-1].T):
    # y = np.ones(x.size) * y
    # y += np.random.randn() * 0.2
    ax[0].scatter(x, y, color = c)
    ax[0].plot(x, y, color = 'k', zorder = 0)

xl = "Adjusted integrated mutual information $\overline{\mu} (s_i)$"
yl = "Asymptotic information ($\omega$)"
ax[0].format(
    # yscale = "log",
    xlabel = xl,
    ylabel = yl
)

for cu, p in zip(curvature, pos.values()):
    ax[1].scatter(*p, s = abs(cu)*1000)
ax[1].axis("equal")
fig.show()

#+end_src

#+RESULTS: imi vs asymp
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Input In [77], in <cell line: 19>()
     12 yl = "Asymptotic information ($\omega$)"
     13 ax[0].format(
     14     # yscale = "log",
     15     xlabel = xl,
     16     ylabel = yl
     17 )
---> 19 for cu, p in zip(curvature, pos.values()):
     20     ax[1].scatter(*p, s = abs(cu)*1000)
     21 ax[1].axis("equal")

NameError: name 'curvature' is not defined
#+end_example
#+attr_org: :width 601 :height 309
[[file:./.ob-jupyter/572aba71f9013a3db3fad0853a7988c73188ffd8.png]]
:END:



#+name:test
#+begin_src jupyter-python
nx.get_edge_attributes(G, "ricciCurvature")
curvature = np.zeros(len(G))
for idx, node in enumerate(G.nodes()):
    curvature[idx] = G.nodes[node]["ricciCurvature"]

imi = np.stack(ndf.imi)
c = ccolors(len(imi[:-1]))
fig, ax = plt.subplots(ncols = 2, sharex = 0, sharey = 0)
for ci, x, y in zip(c, imi[:-1].T, curvature[:, None]):
    y = np.ones(x.size) * y
    y += np.random.randn() * 0.2
    ax[0].scatter(x, y, color = c)
    ax[0].plot(x, y, color = 'k', zorder = 0)
ax[0].format(
    # yscale = "log",
    xlabel = "Integrated mutual information",
    ylabel = "Curvature"
)

for cu, p in zip(curvature, pos.values()):
    ax[1].scatter(*p, s = abs(cu)*1000)
ax[1].axis("equal")
fig.show()

#+end_src

#+RESULTS: test
:RESULTS:
: /tmp/ipykernel_125818/2512316664.py:23: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 621 :height 302
[[file:./.ob-jupyter/420d197a33bf017747410e88d708cbea17b28662.png]]
:END:



#+begin_src jupyter-python
fig, ax = plt.subplots(ncols = 3)
ax[1].format(abc = 1,
             abc_kw = dict(text = "I want this",
                           ))
ax.format()
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_125818/3323414287.py:6: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 834 :height 300
[[file:./.ob-jupyter/4386d29376e153d09de138aaa80dc0a80ded9525.png]]
:END:





8alkdfja
#+begin_src jupyter-python
from plexsim.utils.graph import *
g = recursive_tree(4)
g = nx.convert_node_labels_to_integers(g)

g.add_edge(1, 2)
g.add_edge(2, 3)
g.add_edge(3, 4)
g.add_edge(4, 1)

g = nx.Graph()
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(0, 3)

g.add_edge(1, 4)
g.add_edge(1, 5)

g.add_edge(2, 6)
g.add_edge(2, 7)

g.add_edge(3, 8)
g.add_edge(3, 9)


beta = 0.567
m = models.Potts(g, t = beta, sampleSize = 1)
fig, ax = plt.subplots()
s = m.simulate(100000).mean(1)
ax.plot(s)
ax.format()
fig.show()
#+end_src


check order data
#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from pathlib import Path
from imi import infcy

base = Path("./data")
import re
tmp = []
for fp in base.iterdir():
    # load data
    if "order" in fp.name:
        order = int(re.findall("order=\d+", fp.name)[0].split("=")[1])
        n_samples = int(re.findall("T=\d+", fp.name)[0].split("=")[1])
        df = pd.read_pickle(fp)
        g = df.attrs["settings"].g
        n = len(g)
        for index, row in df.iterrows():
            for node in range(n):
                r = dict(n_samples = n_samples, order = order,
                           imi = row.imi[node],
                           rmse = row.rmse[node],
                           mag = row.mag)
                tmp.append(r)
df = pd.DataFrame(tmp)
#+end_src

#+RESULTS:
: Using numpy


#+begin_src jupyter-python
print(len(dfs))
errors = []

edf = pd.DataFrame(columns = "order mag rmse".split())
errors = np.zeros((len(dfs), 15, 13))

tmp = []
for idx, (k, v) in enumerate(dfs.items()):
    for index, row in v.iterrows():
        for node, i in enumerate(row.rmse):
            info = dict(node = node, rmse = i,
                        order = k, mag = row.mag)
            tmp.append(info)
edf = pd.DataFrame(tmp)

n = np.unique(edf.order).size
fig, axs = plt.subplots(ncols = n)
for ax, (group, dfi) in zip(axs, edf.groupby("order")):
    ax.scatter(dfi.mag, dfi.rmse, label = group,
               alpha = 1)
    ax.set_title(f"Order = {group}")
ax.legend(loc = 'r', ncols = 1)
# ax.format(yscale = "log")
title = f"RMSE for N={n_samples}"
fig.suptitle(title)
fig.savefig(title)
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: NameError                                 Traceback (most recent call last)
: Input In [363], in <cell line: 1>()
: ----> 1 print(len(dfs))
:       2 errors = []
:       4 edf = pd.DataFrame(columns = "order mag rmse".split())
:
: NameError: name 'dfs' is not defined
:END:

#+begin_src jupyter-python
n = df.order.unique().size
fig, axs = plt.subplots(ncols = n)
for ax, (idx, dfi) in zip(axs, df.groupby("order")):
    for jdx, dfj in dfi.groupby("n_samples"):
        ax.scatter(dfj.mag, dfj.rmse, label = jdx)
    ax.set_title(f"Order = {idx}")
ax.legend(title = "n_samples=")
ax.format(yscale = "log")
fig.show()
fig.savefig("plot_error.png")

#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_1035311/282305055.py:9: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 1144 :height 318
[[file:./.ob-jupyter/e590c70e19d5f3ecfdf0d43c70a9f25a14796bee.png]]
:END:

#+begin_src jupyter-python
n = df.order.unique().size
fig, axs = plt.subplots(ncols = n)
for ax, (idx, dfi) in zip(axs, df.groupby("order")):
    for jdx, dfj in dfi.groupby("n_samples"):
        ax.scatter(dfj.mag, dfj.imi, label = jdx)
    ax.set_title(f"Order = {idx}")
ax.legend(title = "n_samples=")
ax.format(yscale = "log")
fig.show()
fig.savefig("plot_imi.png")

#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_1035311/2266819817.py:9: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 1151 :height 318
[[file:./.ob-jupyter/e832a9fd42dafe927ffbaed52134fe8e054724fd.png]]
:END:



#+begin_src jupyter-python
fps = ("exact_random_tree_dyn=ising_beta=0.9001444450539172_T=200.pkl",
'exact_LCF_graph_n=10_repeat=3_shift_list=[-2]_dyn=ising_beta=0.5163880591716167_T=200.pkl',
       'exact_LCF_graph_n=10_repeat=6_shift_list=[-2]_dyn=ising_beta=0.37441921144973944_T=200.pkl'
       )
f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
r = {}
for fp in fps:
   df = pd.read_pickle(base / fp)
   ndf = fit_curve(df, f, offset = True)
   r[fp] = ndf
#+end_src

#+RESULTS:
#+begin_example
/tmp/ipykernel_1047557/2889548462.py:5: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
0.55/tmp/ipykernel_1047557/2889548462.py:5: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
/tmp/ipykernel_1047557/2889548462.py:5: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
0.75/tmp/ipykernel_1047557/2889548462.py:5: RuntimeWarning: overflow encountered in exp
  f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
/home/casper/miniconda3/lib/python3.9/site-packages/scipy/optimize/_numdiff.py:576: RuntimeWarning: invalid value encountered in subtract
  df = fun(x) - f0
0.750.85000000000000010.95000000000000011.05
#+end_example


#+begin_src jupyter-python
import matplotlib.pyplot as pplt
fig, axs = pplt.subplots(nrows = len(r),
                       ncols = 5,
                         figsize = (5,5)
                      )
from matplotlib.collections import LineCollection as LC
for idx, (k, v) in enumerate(r.items()):
    print(k)
    g = v.attrs["settings"].g
    pos = nx.kamada_kawai_layout(g)
    # pos = nx.forceatlas2_layout(g)
    p = np.asarray(list(pos.values()))

    imi = np.stack(v.imi)
    for jdx in range(1, 6):
        s = imi[jdx]
        s = minmax_scale(s) * 50
        ax = axs[idx, jdx - 1]

        lc = LC([[pos[x], pos[y]] for x, y in g.edges()],
                color = 'k', zorder = 0)
        ax.add_artist(lc)
        ax.scatter(*p.T, s = s, c = c)
        # nx.draw(g, pos, ax = ax, node_size = s,
                # node_color = c)
        ax.axis("square")
        ax.axis('off')

for idx, ax in enumerate(axs[0, :]):
    ax.set_title(f"{v.mag[idx + 1] - 0.05: 0.2f}", fontsize = 8)

# axs.format(fontsize = 24)
fig.subplots_adjust(wspace = 0, hspace = 0,
                    left = 0, right = 1)

fig.suptitle("System stability\n Fraction of nodes with state +1",
             fontsize = 8)
fig.savefig("./figures/imi_other_graphs.pdf", bbox_inches = "tight")
#+end_src



#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
g = nx.grid_graph((32, 32))
m = models.Bornholdt(g, t = 1.5, alpha = 4, sampleSize = 1)
s = m.simulate(100000)
#+end_src

#+RESULTS:

#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
g = nx.grid_graph((32, 32))
m = models.Bornholdt(g, t = 1.5, alpha = 4, sampleSize = 1)
s = m.simulate(100000)

import time
fig, ax = plt.subplots()
h = ax.imshow(s[0].reshape(32, 32), vmin = 0, vmax = 1)
idx = 0

fig.canvas.draw()
fig.show()
plt.show()
print("running")
while True:
    h.set_data(s[idx].reshape(32, 32))
    idx += 1
    idx = idx % s.shape[0]
    time.sleep(1e-8)

#+end_src

#+RESULTS:
:RESULTS:
: running
# [goto error]
: ---------------------------------------------------------------------------
: KeyboardInterrupt                         Traceback (most recent call last)
: Input In [11], in <cell line: 12>()
:      13 idx += 1
:      14 idx = idx % s.shape[0]
: ---> 15 time.sleep(1e-8)
:
: KeyboardInterrupt:
: virtual void QEventDispatcherUNIX::registerSocketNotifier(QSocketNotifier*): Multiple socket notifiers for same socket 11 and type Read
:END:
