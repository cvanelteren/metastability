#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
import warnings
warnings.filterwarnings('ignore')

g = nx.krackhardt_kite_graph()
fp = "kite_exact_trajectories_local_target=0_steps=5_local_max=False.pkl"
# fp = "kite_exact_trajectories_local_target=0.5_steps=5.pkl"
# fp = "kite_exact_trajectories_local_target=0_steps=10_to1.pkl"
# fp = "kite_exact_trajectories_local_target=0.5_steps=5.pkl"
# fp = "kite_exact_trajectories_local_max.pkl"
# fp = "tmp.pkl"

# fp = "kite_exact_trajectories_local_target=0.5_steps=3.pkl"
df = pd.read_pickle(fp)
df.head(1)
from exact import *
import numpy as np
n = len(g)
states, allowed = gen_states(n)
def is_tipping(row):
    s = np.array([states[i] for i in row.state])
    return np.mean(states[row.state[-1]]) == 0.5

ps = np.nansum(np.log(np.stack(df.ps)), -1)
idx = np.argmax(ps)

target = np.percentile(ps, 100)
idxs = np.where(ps >= target)[0]

# df["is_tipping"] = df.apply(is_tipping, axis = 1)
# from utils import ccolors
# tmp = df[df.is_tipping]
# print(df.shape)
# ps = np.log(np.stack(tmp.ps))
# lol = np.argsort(np.nansum(ps, axis = -1))
# idx  = lol[-1]
# highest = np.nansum(ps[idx])
# idxs = np.where(np.nansum(ps,-1) == highest)[0]
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
---------------------------------------------------------------------------
FileNotFoundError                         Traceback (most recent call last)
Input In [1], in <cell line: 17>()
      9 fp = "kite_exact_trajectories_local_target=0_steps=5_local_max=False.pkl"
     10 # fp = "kite_exact_trajectories_local_target=0.5_steps=5.pkl"
     11 # fp = "kite_exact_trajectories_local_target=0_steps=10_to1.pkl"
     12 # fp = "kite_exact_trajectories_local_target=0.5_steps=5.pkl"
   (...)
     15
     16 # fp = "kite_exact_trajectories_local_target=0.5_steps=3.pkl"
---> 17 df = pd.read_pickle(fp)
     18 df.head(1)
     19 from exact import *

File ~/miniconda3/lib/python3.9/site-packages/pandas/io/pickle.py:187, in read_pickle(filepath_or_buffer, compression, storage_options)
    124 """
    125 Load pickled pandas object (or any object) from file.
    126
   (...)
    184 4    4    9
    185 """  # noqa: E501
    186 excs_to_catch = (AttributeError, ImportError, ModuleNotFoundError, TypeError)
--> 187 with get_handle(
    188     filepath_or_buffer,
    189     "rb",
    190     compression=compression,
    191     is_text=False,
    192     storage_options=storage_options,
    193 ) as handles:
    194
    195     # 1) try standard library Pickle
    196     # 2) try pickle_compat (older pandas version) to handle subclass changes
    197     # 3) try pickle_compat with latin-1 encoding upon a UnicodeDecodeError
    199     try:
    200         # TypeError for Cython complaints about object.__new__ vs Tick.__new__
    201         try:

File ~/miniconda3/lib/python3.9/site-packages/pandas/io/common.py:798, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)
    789         handle = open(
    790             handle,
    791             ioargs.mode,
   (...)
    794             newline="",
    795         )
    796     else:
    797         # Binary mode
--> 798         handle = open(handle, ioargs.mode)
    799     handles.append(handle)
    801 # Convert BytesIO or file objects passed with an encoding

FileNotFoundError: [Errno 2] No such file or directory: 'kite_exact_trajectories_local_target=0_steps=5_local_max=False.pkl'
#+end_example
:END:



#+begin_src jupyter-python
val = np.percentile(ps, 100)
kdx = np.where(ps == val)[0]
print(kdx.shape)

fig, ax = plt.subplots()
ax.plot(ps[k])
ax.scatter(kdx, ps[kdx])
ax.format()
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
: (1,)
#+attr_org: :width 302 :height 282
[[file:./.ob-jupyter/052cd9bbb6ae56f3919212b236733f86a0c5cb97.png]]
:END:



#+begin_src jupyter-python
def plot_trajectory(idx, ax):
    most_path = df.state.iloc[idx]
    most_states = np.array([states[i] for i in most_path])
    c = ccolors(2)
    pos = nx.kamada_kawai_layout(g)
    for s, axi in zip(most_states, ax):
        nx.draw(g, pos = pos, ax = axi,
                node_color = c[s.astype(int)], with_labels = 1,
                font_color = "white")
        axi.set_title(f"{s.mean():0.2f}", fontsize = 24)
    ax.format()
    ax.axis("equal")

from utils import ccolors
# plt.config.use_style("seaborn-poster")
from matplotlib.pyplot import Line2D
from tqdm import tqdm
idxs = np.arange(len(ps))
val = np.percentile(ps, 99.9)
idxs = np.where(ps >= val)[0]
for idx in tqdm(idxs):
    ncols = len(df.state.iloc[idx])
    fig, ax = plt.subplots(ncols = ncols)
    plot_trajectory(idx, ax)
    handles = [Line2D([], [], color = c, label = f"{idx}",
                    linestyle = 'none', marker = 'o') for idx, c in enumerate(ccolors(2))]
    fig.legend(loc = "b",
               handles = handles,
               fontsize = 30,
               title = "Node state",
               title_fontsize = 24,
               prop = dict(size = 20),
               markerscale = 2)
    fig.suptitle("Fraction of nodes in +1", fontsize = 32)
    fp = f"./figures/kite_maximized_trajectory_{idx}_maxj.pdf"
    print(fp)
    ax.set_title(ps[idx])
    fig.savefig(fp) ,
    fig.show()
#+end_src

#+begin_src jupyter-python
import matplotlib.pyplot as pplt
from utils import ccolors
C = ccolors(10)
pos = nx.kamada_kawai_layout(g)
t = flip.shape[0]
fig, ax = plt.subplots(ncols = t)
timing = np.arange(t)#  - t//2
for ti, (flipi, axi) in enumerate(zip(flip, ax)):
    nx.draw(g, pos = pos, ax = axi, node_size = 0, alpha = 0.2,
            )
    tmp = np.asarray([i for i in pos.values()])
    # print(flipi)
    flipi /= flipi.max()
    axi.scatter(*tmp.T, s = flipi * 200, color = C)
    print(np.argsort(flipi))
    axi.set_title(f"t = {timing[ti]}")
    axi.axis("equal")
# ax.axis("equal")
# ax.format()
fig.tight_layout()
fig.savefig("test2")
fig.show()
#+end_src


#+begin_src jupyter-python
def flip_prob(df, states, p, p0):
    from exact import to_binary
    # get state indices and compute the probability for each node to flip
    # to its opposite state
    state_idx = np.stack(df.state)
    n_states, t = state_idx.shape
    n = states.shape[1] # 2**n x n

    print(state_idx.shape)
    flip = np.zeros((t, n))
    for ti in tqdm(range(t)):
        sidx = state_idx[:, ti]

        p_ = np.zeros(p0.size)
        p_[sidx] = p0[sidx]
        p_ /= p_.sum()

        # p_ = p0.copy()

        # if ti == 0:
        #     p_ = p0.copy()
        # else:
        #     p_ = np.zeros(p0.size)
        #     for pi in sidx:
        #         p_[pi] += 1 / len(sidx)

        fig, ax = plt.subplots()
        ax.plot(p_)
        ax.format()
        fig.show()

        print(p_.sum())
        # p_[sidx] = p0[sidx]
        # p_ /= p_.sum()
        for idx in sidx:
            state = states[idx]
            for node, si in enumerate(state):
                tmp = state.copy()
                tmp[node] = abs(si - 1)
                assert abs(state - tmp).sum() == 1, (state - tmp, state, tmp, idx, other)
                other = to_binary(tmp)
                # compute prob of flipping
                flip[ti, node] += p_[idx] * p[idx, other]
    flip /= flip.sum(1)[:, None]
    return flip

from exact import gen_states, ising, get_transfer, Settings
A = nx.adjacency_matrix(g).todense()
states, allowed = gen_states(n)
E = ising(states, A)

g = nx.krackhardt_kite_graph()
beta = 0.5732374683235916
# ignore model here, not needed
settings = Settings(beta=beta, g=g, steps=5, model=None)
p, p0 = get_transfer(n, E, settings.beta, allowed, states)
flip = flip_prob(df, states, p, p0)
print(flip.shape)
#+end_src


#+begin_src jupyter-python
import matplotlib.pyplot as pplt
from utils import ccolors
C = ccolors(10)
pos = nx.kamada_kawai_layout(g)
t = flip.shape[0]
fig, ax = plt.subplots(ncols = t)
timing = np.arange(t)#  - t//2
for ti, (flipi, axi) in enumerate(zip(flip, ax)):
    nx.draw(g, pos = pos, ax = axi, node_size = 0, alpha = 0.2,
            )
    tmp = np.asarray([i for i in pos.values()])
    # print(flipi)
    flipi /= flipi.max()
    axi.scatter(*tmp.T, s = flipi * 200, color = C)
    print(np.argsort(flipi))
    axi.set_title(f"t = {timing[ti]}")
    axi.axis("equal")
# ax.axis("equal")
# ax.format()
fig.tight_layout()
fig.savefig("test2")
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
: [8 3 7 0 1 9 4 2 6 5]
: [3 1 0 8 9 4 2 6 5 7]
: [3 0 1 5 6 2 4 8 9 7]
: [3 5 6 0 1 2 4 7 9 8]
#+attr_org: :width 1050 :height 429
[[file:./.ob-jupyter/a81f1995707b0500762aafb74f4fa24b083ace90.png]]
:END:

#+begin_src jupyter-python
def when_do_we_flip(df, states):
    paths = np.stack(df.state)
    n, t = paths.shape
    nodes = states.shape[1]
    flipped = np.zeros((nodes, t))
    for ti in range(1, t):
        for ni in range(n):
            s = states[paths[ni, ti]]
            s_past = states[paths[ni, ti - 1]]
            node = np.where(abs(s - s_past))[0]
            flipped[node, ti] += 1
    return flipped

flipped = when_do_we_flip(df, states)
print(flipped.shape)

#+end_src

#+begin_src jupyter-python
%matplotlib inline
idx = np.stack(df.state)

fig, ax = plt.subplots()
ps = np.zeros(p0.size)
x = np.arange(0, ps.size)
base = 0

for tidx, idx in enumerate(np.stack(df.state).T):
    ps.fill(0)
    ps[idx] = p0[idx]
    ps /= ps.sum()
    y = -(ps + tidx)
    idx = np.where(y == np.min(y))[0]
    ax.plot(y, x, color = "tab:blue")
    ax.scatter(y[idx], x[idx])
    base += ps.max()
ps = np.log(np.stack(df.ps)).sum(-1)
idx = np.argmax(ps)

y = np.stack(df.state)[idx]
x = np.arange(0, y.size) + np.stack(df.ps)[idx]

ax.plot(-x, y, color = "k", marker = 'o', s = 3)
ax.format(
xlabel = "Time(t)", ylabel = "$P(S^t)$",
title = "Path analysis tipping points")
fig.show()
plt.show()
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 329 :height 323
[[file:./.ob-jupyter/76e378c9190db360a065cfb2e4bc1e1886f8d669.png]]
:END:

#+begin_src jupyter-python
print(expectations)
fig, ax = plt.subplots()
ax.imshow(expectations)
ax.format()
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: [[0.  0.  0.  0.  0.  0.  0.  0.  0.  0. ]
:  [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
:  [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
:  [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
:  [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
:  [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]]
#+attr_org: :width 277 :height 182
[[file:./.ob-jupyter/51018bcbdc091a24920e05fe72c6bea097b72d0e.png]]
:END:


#+begin_src jupyter-python
import matplotlib.pyplot as pplt
t = len(expectations)
fig, ax = plt.subplots(ncols = t)
pos = nx.kamada_kawai_layout(g)
xy = np.array(list(pos.values()))
from utils import ccolors
plt.config.use_style("seaborn-poster")
c = ccolors(len(g))
g = nx.krackhardt_kite_graph()
mag = np.linspace(0, 0.5, expectations.shape[0])
for t, (axi, exp) in enumerate(zip(ax, expectations)):
    # s = (exp - exp.min()) / (exp.max() - exp.min())
    s = exp
    print(t, s)
    nx.draw_networkx_edges(g, pos = pos, ax = axi, alpha = 0.2)
    axi.scatter(*xy.T, s = s * 10, c = c)
    axi.set_title(mag[t].round(2))
ax.axis('equal')
ax.grid(False)
ax.axis("off")
fig.suptitle("Fraction of nodes with state+1", fontsize = 32)
fig.savefig("./figures/expectation_kite.pdf")
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
0 [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
1 [9.88618198e-04 9.88618198e-04 9.78233227e-03 1.00795773e-05
 9.78233227e-03 9.98283055e-05 9.98283055e-05 9.78233227e-03
 9.60062834e-02 8.72459747e-01]
2 [0.06787307 0.06787307 0.1086497  0.0847056  0.1086497  0.08296401
 0.08296401 0.2404124  0.56804176 0.58786668]
3 [0.27036888 0.27036888 0.24166631 0.29313185 0.24166631 0.26676218
 0.26676218 0.29805152 0.46635718 0.38486471]
4 [0.40317429 0.40317429 0.36288541 0.46206092 0.36288541 0.42746
 0.42746    0.38242826 0.42179721 0.34667421]
5 [0.50845744 0.50845744 0.47390214 0.57455729 0.47390214 0.54301274
 0.54301274 0.48132969 0.47512775 0.4182406 ]
#+end_example
#+attr_org: :width 1583 :height 488
[[file:./.ob-jupyter/e453216fed5c8226039ce7c277ea60095d380542.png]]
:END:
alkdjfa
#+begin_src jupyter-python
for trajectory in trajectories:
    fig, ax = plt.subplots(ncols = trajectory.size)
    for axi, state_idx in zip(ax, trajectory):
        s = states[state_idx]
        ci = c[s.astype(int)]
        nx.draw(g, pos = pos, ax = axi, node_color = ci,
                with_labels = 1, font_color = 'w')
    ax.axis("equal")
#+end_src

alkdjfalkdjfldk
#+begin_src jupyter-python
for idx in idxs:
    most_path = tmp.iloc[idx].state
    most_states = np.array([states[i] for i in most_path])
    print(idx, ps[idx])
    print(most_states)
    print("-"*32)
#+end_src

#+RESULTS:
#+begin_example
9070 [-9.18246351 -4.69172492 -2.99573227 -4.69172492 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 1. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 1. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 1. 0. 0. 1. 0. 1. 1. 1.]]
--------------------------------
15119 [-9.18246351 -4.69172492 -2.99573227 -4.69172492 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 1. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 1. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 1. 0. 1. 1. 1. 1.]]
--------------------------------
28222 [-4.69172492 -9.18246351 -2.99573227 -4.69172492 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 1. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 1. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 1. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 1. 0. 0. 1. 0. 1. 1. 1.]]
--------------------------------
28895 [-4.69172492 -9.18246351 -2.99573227 -4.69172492 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 1. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 1. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 1. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 1. 0. 1. 1. 1. 1.]]
--------------------------------
30214 [-4.69172492 -2.99573227 -4.69172492 -9.18246351 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 1. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 1. 0. 0. 1. 0. 1. 1. 1.]]
--------------------------------
30227 [-4.69172492 -2.99573227 -4.69172492 -9.18246351 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 1. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 1. 0. 1. 1. 1. 1.]]
--------------------------------
30230 [-4.69172492 -2.99573227 -4.69172492 -9.18246351 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 0. 1. 0. 1. 1. 1.]
 [0. 0. 1. 0. 0. 1. 0. 1. 1. 1.]]
--------------------------------
30233 [-4.69172492 -2.99573227 -4.69172492 -9.18246351 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 0. 1. 0. 1. 1. 1.]
 [0. 0. 0. 0. 0. 1. 1. 1. 1. 1.]]
--------------------------------
30238 [-4.69172492 -2.99573227 -4.69172492 -9.18246351 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 0. 0. 1. 1. 1. 1.]
 [0. 0. 0. 0. 1. 0. 1. 1. 1. 1.]]
--------------------------------
30239 [-4.69172492 -2.99573227 -4.69172492 -9.18246351 -4.69172492]
[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 0. 0. 0. 0. 0. 1. 1.]
 [0. 0. 0. 0. 0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 0. 0. 0. 1. 1. 1. 1.]
 [0. 0. 0. 0. 0. 1. 1. 1. 1. 1.]]
--------------------------------
#+end_example



#+begin_src jupyter-python
ps = np.log(np.stack(tmp.ps))

print("-" * 32)
for i in ps[idx]:
    print(i)
print("-" * 32)
for i in ps[lol[-1]]:
    print(i)
print("-" * 32)
#+end_src

#+RESULTS:
#+begin_example
--------------------------------
-4.6917249215108
-2.995732273553991
-4.6917249215108
-9.182463510965073
-4.6917249215108
--------------------------------
-4.6917249215108
-2.995732273553991
-4.6917249215108
-9.182463510965073
-4.6917249215108
--------------------------------
#+end_example


#+RESULTS:
:RESULTS:
#+begin_example
10
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_55794/348484254.py:20: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_55794/348484254.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
#+end_example
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/9d8c34819972cc592475498a2f63ca9668e92935.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/3775c2e12e57ade29792d2c2aafd97fcaa63e6b9.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/0ec78825bc06a29bb643f1c5d616bee307851537.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/eb876d8ae20c1ba2be0dfc3be0b04d9e7d351e09.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/f2f955c8a80db8f52945a7f4c4df01e3a41d05fb.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/c64bac7f9f5669fa9d4abfc1c1428ef2e7394f42.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/6ea2f60855055535f66afe14b43bdff142203c5f.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/5f0cdcc3c0b421e38e70dd8ddf1fb6f98d7cc96e.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/8298cd7f6544444019e120fa72d5c36ecb661485.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/0ae86bc633d67a5c09eef2c98019209de6cbfd2e.png]]
#+begin_example
/tmp/ipykernel_74477/2289240082.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_74477/2289240082.py:21: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_74477/2289240082.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_74477/2289240082.py:21: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_74477/2289240082.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
/tmp/ipykernel_74477/2289240082.py:21: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
  ax.axis("equal")
/tmp/ipykernel_74477/2289240082.py:32: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
  fig.show()
#+end_example
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/88acddd5636025bfae6cd36e3b48dfcb410e621c.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/5d97144080011d609997b6e00590f7b86945f0e3.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/3453ad85ba400481201e93fb966af7762710ffc2.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/549f52e7ebc74c07261e7f774627c2f44c2d14a8.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/dcf9d53c886449d1b91e5ac6c010c146a5c10d67.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/14bfa786a9ef765b9ef65201dc0c068edba2ac91.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/9d8c34819972cc592475498a2f63ca9668e92935.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/eb876d8ae20c1ba2be0dfc3be0b04d9e7d351e09.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/8298cd7f6544444019e120fa72d5c36ecb661485.png]]
#+attr_org: :width 1575 :height 505
[[file:./.ob-jupyter/0ae86bc633d67a5c09eef2c98019209de6cbfd2e.png]]
: /tmp/ipykernel_74477/3842260443.py:33: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
:  20% 2/10 [00:08<00:33,  4.18s/it]/tmp/ipykernel_74477/3842260443.py:21: ProplotWarning: Calling arbitrary axes methods from SubplotGrid was deprecated in v0.8 and will be removed in a future release. Please index the grid or loop over the grid instead.
:   ax.axis("equal")
:END:
#+begin_src jupyter-python
print(len(idx))
#+end_src

#+RESULTS:
: 10

#+begin_src jupyter-python
from exact import *
g = nx.krackhardt_kite_graph()
beta = 0.5732374683235916
settings = Settings(beta=beta, g=g, steps=5, model=None)
A = nx.adjacency_matrix(g).todense()
states, allowed = gen_states(n)
E = ising(states, A)
p, p0 = get_transfer(n, E, settings.beta, allowed)
#+end_src

#+RESULTS:
: 100% 1024/1024 [00:00<00:00, 15460.81it/s]
: 100% 1024/1024 [00:00<00:00, 1725.49it/s]

#+begin_src jupyter-python
d = np.log(p)
d[np.isfinite(d) == False] = -1e20
#+end_src

#+RESULTS:

#+begin_src jupyter-python
fig, ax = plt.subplots()
h = ax.imshow(d, cmap = "viridis")
ax.format()
fig.colorbar(h)
fig.savefig("./test.png")
fig.show()
np.allclose(p, (1 - p).T)
#+end_src

#+RESULTS:
:RESULTS:
: False
#+attr_org: :width 384 :height 300
[[file:./.ob-jupyter/dc553c73a26ada7f4ac3392ba65eb8cc9a8d12f9.png]]
:END:

#+begin_src jupyter-python
beta = 0.5732374683235916
print(1/(1 + np.exp(6 * beta)))
print(1/(1 + np.exp(6 * beta)))
#+end_src

#+RESULTS:
: 0.03108580391136416


#+begin_src jupyter-python
from exact import ising, get_transfer, Settings, NodeToSystem, gen_states
import cupy as cp
beta = 0.5732374683235916
T = 1
g = nx.krackhardt_kite_graph()
n = len(g)
A = nx.adjacency_matrix(g).todense()
states, allowed = gen_states(n)
settings = Settings(beta, T, g, NodeToSystem)
E = ising(cp.asarray(states), cp.asarray(A))
p, p0 = get_transfer(n, E, settings.beta, allowed, states)

#+end_src

#+RESULTS:
: 100% 1024/1024 [00:00<00:00, 9099.31it/s]

#+begin_src jupyter-python
p_start = p0.copy()
for idx, s in enumerate(states):
    if np.mean(s) != 0.5:
        p_start[idx] = 0
p_start /= p_start.sum()

#+end_src

#+RESULTS:


#+begin_src jupyter-python
from collections import Counter
from exact import to_binary, gen_binary
paths = np.stack(df.state)
ps  = np.log(np.stack(df.ps)).sum(-1)
c = Counter(paths[:, -1])

x = np.arange(2**10)
y = np.zeros(x.size)

N = 0
for idx, p in enumerate(ps):
    end = paths[idx, -1]

    if gen_binary(end, 10).mean() != 0.5:
         continue
    else:
        y[end] +=  p
        N+=1

y /= y.sum()
print(y.sum(), N)
#+end_src

#+RESULTS:
: 1.0 30240


#+begin_src jupyter-python
print(len(c))
print(c)
print(paths[5])
print(gen_binary(512, 10))
#+end_src

#+begin_src jupyter-python
print(np.unique(y))
#+end_src

#+RESULTS:
: [0.]


#+begin_src jupyter-python
fig, ax = plt.subplots()
ax.plot(x, p_start, label = "Stationary")
ax.plot(x, y, label = "Trajectory from <S> = 0")
ax.format(xlabel = "State(S)", ylabel = "P(S)")
ax.legend(loc = "t")
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 328 :height 331
[[file:./.ob-jupyter/efff153bb5597ede42168d0e09f8fddf0a2f9e99.png]]
:END:

#+begin_src jupyter-python
a = y[:y.size//2]
b = y[y.size // 2:][::-1]
fig, ax = plt.subplots()
ax.plot(a, label = "first 512 states")
ax.plot(b, alpha = 0.5, label = "second 512 states")
ax.format(xlabel = 'state (S)', ylabel = "P(S)")
ax.legend(loc = "t")
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 332 :height 331
[[file:./.ob-jupyter/a22d03b94ae092ed22956c8a5b84cbfe06a91a6b.png]]
:END:
