#+begin_src jupyter-python
#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
from pathlib import Path
import re

base = Path("./data")
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"

# fp = "exact_kite_dyn=bornholdt_beta=0.12568738973509125_T=200.pkl"
# fp = "exact_kite_dyn=bornholdt_beta=0.23708107265108683_T=200.pkl"
fp = "exact_kite_dyn=sis_beta=9.122104355448496_T=200.pkl"
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"
# fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=1000.pkl"
# fp = "exact_small_tree_dyn=ising_beta=0.9001444450539172_T=200.pkl"

n_samples = int(re.findall("T=\d+", fp)[0].split("=")[1])


# fp = "exact_recursive_tree_4_beta=0.567_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=1_matching=0.7_beta=0.4272728243801874_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=5_matching=0.9_beta=0.4115334169153415_T=200.pkl"
# fp = "exact_circle_beta=0.567_T=200.pkl"
from exact_utils import fit_curve
df = pd.read_pickle(base / Path(fp))
f = lambda x, a, b, c, d, g: a * np.exp(-b * x) + c * np.exp(-d * x) + g
ndf = fit_curve(df, f, offset = True)
#+end_src

#+RESULTS:
: 1.05

#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy

from sklearn.preprocessing import minmax_scale
from utils import ccolors
print(ndf.columns)
imi = np.stack(ndf.imi)
asy = np.stack(ndf.asymp)
mi = np.stack(ndf.mi)

h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

import matplotlib.pyplot as pplt

fig, axs = plt.subplots(nrows = 3,
                        ncols = n,
                        # sharex = 'row',
                        # sharey = 'row',
                        share = 1,
                        span = "row",
                        # height_ratios = [0.5, 1],
                        # figsize = (5,5),
                        # constrained_layout = True
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
tits = []
pos_ = np.array([i for i in pos.values()])
for ax, axj, axk,  t in zip(axs[0,:], axs[1,:], axs[2,:], targets):
    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    axj.add_artist(lc)

    axj.axis("off")
    axj.axis("equal")

    idx = np.where(mag.round(1) == t)[0][0]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    tits.append(tit)
    # ax.set_title(f"{tit:.2f}",
                 # y = 1.3,
                 # fontsize = 8,
                 # )

    for node, (ci, x, si) in enumerate(zip(c, pos.values(), s)):
        s = imi[idx]
        s /= s.max()
        ax.scatter(*x, s = s[node]*600, color = ci)

        s = asy[idx]
        s /= s.max()
        axj.scatter(*x, s = s[node]*600, color = ci)


        # axk.scatter(asy[idx], imi[idx], color = c)
        axk.plot(mi[idx, :, node], color = ci)

    # axk.scatter(asy[idx], imi[idx], color = c, s = 500)
    # axk.axis("equal")

# axs.format(fontsize = fs)
# axs.axis('off')
axs[2, :].set_xlabel("Time(t)")
axs[2, :].format(xlim = (0, 100))
axk.set_ylabel("$I(s_i : S'^t)$")

# axs[2,:].set_xlabel("Asymptotic information")
# axk.set_ylabel("Integrated mutual\ninformation")

fig.suptitle("System Stability\nFractions of nodes in +1",
             fontsize = 24,
             )
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]

axs[0,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "a"))
axs[1,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "b"))
axs[2,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "c"))

for idx, t in enumerate(tits):
    axs[0, idx].set_title(round(t,2), y = 0.95)
fig.savefig(f"./figures/{dyn}_kite_graph.pdf")
fig.savefig("./figures/figure2.pdf")
#+end_src

#+RESULTS:
:RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0', 'coeffs', 'half', 'asymp', 'imi', 'rmse'], dtype='object')
#+attr_org: :width 1747 :height 1466
[[file:./.ob-jupyter/73dc3707911fe9eec95702995d05bf80a5b6cf4e.png]]
:END:

#+begin_src jupyter-python
fig, ax = pplt.subplots(ncols = 3)
for axi in ax:
    axi.scatter(*pos_.T, s = np.random.randint(1, 10, size = len(pos))*5)
    axi.axis('equal')
    axi.axis('off')
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_224402/473138156.py:6: UserWarning: Matplotlib is currently using module://matplotlib_inline.backend_inline, which is a non-GUI backend, so cannot show the figure.
:   fig.show()
#+attr_org: :width 400 :height 400
[[file:./.ob-jupyter/c190332e053880faab2204f03654560891d1e76d.png]]
:END:


for appendix
#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy

from sklearn.preprocessing import minmax_scale
from utils import ccolors
imi = np.stack(ndf.imi)
asy = np.stack(ndf.asymp)
h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

fig, axs = plt.subplots(nrows = 3,
                        ncols = n,
                        share = 1,
                        span = "row",
                        # spany = "row",
                        # height_ratios = [0.5, 1],
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
for ax, axj, axk,  t in zip(axs[0,:], axs[1,:], axs[2, :], targets):
    idx = np.where(mag.round(1) == t)[0][0]
    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")
    p = ndf.p0.iloc[idx]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    ax.set_title(f"{tit:.2f}",)

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    axj.add_artist(lc)
    axj.axis("off")
    axj.axis("equal")
    for node, (ci, x, si) in enumerate(zip(c, pos.values(), s)):
        s = imi[idx]
        s /= s.max()
        ax.scatter(*x, s = s[node]*600, color = ci)

        s = asy[idx]
        s /= s.max()
        axj.scatter(*x, s = s[node]*600, color = ci)
        axk.plot(df.mi.iloc[idx][:, node], color = ci)

axs[0, :].format(fontsize = fs,
                 )

fig.suptitle("System Stability\nFractions of nodes in +1")
axs[0,0].format(
    abc = 1,
    abc_kw = dict(text = "a"))

axs[1,0].format(
    abc = 1,
    abc_kw = dict(text = "b"))

axs[2,0].format(
    abc = 1,
    abc_kw = dict(text = "c"))


axs[2,:].format(xlabel = "Time(t)",
                yscale = "log",
                # xscale = "log",
                fontsize = fs,
                )
yl = "$I(s_i : S^t)$"
axs[2,0].set_ylabel(yl, fontsize = fs)
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]
fig.savefig(f"./figures/{dyn}_kite_graph_appendix.pdf")
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 2113 :height 1563
[[file:./.ob-jupyter/803a2aaf16a414696ac6ec4f97ebb830c80ede88.png]]
:END:


#+begin_src jupyter-python
import matplotlib.pyplot as pplt
import networkx as nx
g = nx.florentine_families_graph()
fig, axs = pplt.subplots(2, 2, sharey = "row", sharex = 'row')
for axi in axs[0, :]:
    nx.draw_forceatlas2(g, ax = axi, node_size = 20)
for idx, axi in enumerate(axs[1, :]):
    axi.plot(np.random.rand(2, 100) + idx)

#+end_src

#+RESULTS:
:RESULTS:
: /home/casper/miniconda3/lib/python3.9/site-packages/networkx-2.6rc1.dev0-py3.9.egg/networkx/drawing/layout.py:1278: RuntimeWarning: invalid value encountered in true_divide
:   factor = (tmp / d2) * scaling
#+attr_org: :width 400 :height 400
[[file:./.ob-jupyter/0f45df024ba68dd1040f6b202c3521e679fbc5f1.png]]
:END:
