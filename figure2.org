#+begin_src jupyter-python
%load_ext autoreload
%autoreload 2
import warnings
warnings.filterwarnings('ignore')
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
from pathlib import Path
import re

base = Path("./data")
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"

# fp = "exact_kite_dyn=bornholdt_beta=0.12568738973509125_T=200.pkl"
# fp = "exact_kite_dyn=bornholdt_beta=0.23708107265108683_T=200.pkl"
fp = "exact_kite_dyn=sis_beta=9.122104355448496_T=200.pkl"
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"
fp='exact_kite_dyn=ising_beta=0.5732374683235916_T=300_g.is_directed()=False.pkl'
fp='exact_kite_dyn=ising_beta=0.5732374683235916_T=300_g.is_directed()=False.pkl'
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=2000.pkl"
fp = "exact_0_dyn=ising_beta=0.7724235149856197_T=2000_g.is_directed()=False.pkl"
fp = "exact_2_dyn=ising_beta=0.9001444450539172_T=300_g.is_directed()=False.pkl"
fp='exact_kite_0_dyn=ising_beta=0.5732374683235916_T=300_g.is_directed()=False_NEW.pkl'
fp='exact_kite_0_dyn=ising_beta=0.5732374683235916_T=300_g.is_directed()=False_NEW.pkl'
# fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=30000.pkl"
# fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=310.pkl"
# fp='exact_kite_dyn=ising_beta=0.8333333333333334_T=310_g.is_directed()=False.pkl'
# n_samples = int(re.findall("T=\d+", fp)[0].split("=")[1])
# fp='exact_kite_dyn=ising_beta=0.8333333333333334_T=310_g.is_directed()=False.pkl'
# fp='exact_kite_dyn=ising_beta=0.8333333333333334_T=310_g.is_directed()=False.pkl'
# fp='exact_kite_dyn=ising_beta=0.5732374683235916_T=310_g.is_directed()=False.pkl'
# fp='exact_kite_dyn=ising_beta=0.9001444450539172_T=310_g.is_directed()=False.pkl'

# fp = "exact_recursive_tree_4_beta=0.567_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=1_matching=0.7_beta=0.4272728243801874_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=5_matching=0.9_beta=0.4115334169153415_T=200.pkl"
# fp = "exact_circle_beta=0.567_T=200.pkl"
# fp='./exact_kite_dyn=ising_beta=1_T=310_g.is_directed()=False.pkl'
# fp='./exact_kite_dyn=ising_beta=4_T=310_g.is_directed()=False.pkl'
from exact_utils import fit_curve
df = pd.read_pickle(base / Path(fp))
f = lambda x, a, b, c, d, g: a * np.exp(-b * x) +  c * np.exp(-d * x) + g
# f = lambda x, a, b, c, d, g: a * np.exp(-b * x) +  g
ndf = fit_curve(df, f, offset = True)
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: 1.05


#+begin_src jupyter-python
g = ndf.attrs["settings"].g
fig, ax = plt.subplots()
nx.draw(g, pos = nx.kamada_kawai_layout(g), ax = ax)
ax.axis("equal")
ax.format()
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 262 :height 411
[[file:./.ob-jupyter/5583d4dcf34c04a8d5369b6f7c86577c8df38af2.png]]
:END:

#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy

from sklearn.preprocessing import minmax_scale
from utils import ccolors
print(ndf.columns)
imi = np.stack(ndf.imi)
ai = np.stack(ndf.asymp)
mi = np.stack(ndf.mi)

h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5]
# targets =  [ 0.0125,  0.1375,  0.2625,  0.3875,  0.5125, 0.6375 ]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

import matplotlib.pyplot as pplt

fig, axs = plt.subplots(nrows = 3,
                        ncols = n,
                        # sharex = 'row',
                        # sharey = 'row',
                        share = 1,
                        span = "row",
                        # height_ratios = [0.5, 1],
                        # figsize = (5,5),
                        # constrained_layout = True
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
tits = []
pos_ = np.array([i for i in pos.values()])
for ax, axj, axk,  t in zip(axs[0,:], axs[1,:], axs[2,:], targets):
    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    axj.add_artist(lc)

    axj.axis("off")
    axj.axis("equal")

    print(t, np.where(mag == t), mag == t, mag)
    idx = np.where(mag.round(2) == round(t, 2))[0][0]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    tits.append(tit)
    # ax.set_title(f"{tit:.2f}",
                 # y = 1.3,
                 # fontsize = 8,
                 # )

    for node, (ci, x) in enumerate(zip(c, pos.values())):
        s = imi[idx]
        s /= s.max()
        ax.scatter(*x, s = s[node]*600, color = ci)

        s = asy[idx]
        s /= s.max()
        axj.scatter(*x, s = s[node]*600, color = ci)

        # axk.scatter(asy[idx], imi[idx], color = c)
        axk.plot(mi[idx, :, node], color = ci)

    # axk.scatter(asy[idx], imi[idx], color = c, s = 500)
    # axk.axis("equal")

# axs.format(fontsize = fs)
# axs.axis('off')
axs[2, :].set_xlabel("Time(t)")
axs[2, :].format(xlim = (0, 100))
# axs[2, :].format(yscale = "log", xscale = "log")
axk.set_ylabel("$I(s_i : S'^t)$")

# axs[2,:].set_xlabel("Asymptotic information")
# axk.set_ylabel("Integrated mutual\ninformation")

fig.suptitle("System Stability\nFractions of nodes in +1",
             fontsize = 24,
             )
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]

axs[0,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "a"))
axs[1,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "b"))
axs[2,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "c"))

for idx, t in enumerate(tits):
    axs[0, idx].set_title(round(t,2), y = 0.95)
# fig.savefig(f"./figures/{dyn}_kite_graph.pdf")
# fig.savefig("./figures/figure2.pdf")
#+end_src

#+RESULTS:
:RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0', 'pst', 'psc', 'coeffs', 'half', 'asymp',
:        'imi', 'rmse'],
:       dtype='object')
: 0.1 (array([], dtype=int64),) [False False False False False False False False False False False False] [ 0.    0.1   0.2   0.3   0.4   0.5   0.6   0.7   0.8   0.9   1.   -1.05]
: 0.2 (array([], dtype=int64),) [False False False False False False False False False False False False] [ 0.    0.1   0.2   0.3   0.4   0.5   0.6   0.7   0.8   0.9   1.   -1.05]
: 0.3 (array([], dtype=int64),) [False False False False False False False False False False False False] [ 0.    0.1   0.2   0.3   0.4   0.5   0.6   0.7   0.8   0.9   1.   -1.05]
: 0.4 (array([4]),) [False False False False  True False False False False False False False] [ 0.    0.1   0.2   0.3   0.4   0.5   0.6   0.7   0.8   0.9   1.   -1.05]
: 0.5 (array([5]),) [False False False False False  True False False False False False False] [ 0.    0.1   0.2   0.3   0.4   0.5   0.6   0.7   0.8   0.9   1.   -1.05]
#+attr_org: :width 1539 :height 1400
[[file:./.ob-jupyter/9a94958c5b375c27deb7b6a665b98b7cdf141a8f.png]]
:END:
kalsdfjsl
#+RESULTS:
:RESULTS:
#+begin_src jupyter-python
fig, ax = pplt.subplots(ncols = 3)
for axi in ax:
    axi.scatter(*pos_.T, s = np.random.randint(1, 10, size = len(pos))*5)
    axi.axis('equal')
    axi.axis('off')
fig.show()
#+end_src



#+begin_src jupyter-python
dfi = df[df.mag.round(1) == -1]
mi = np.stack(dfi.mi).squeeze()
fig, ax = plt.subplots()
for mii, ci in zip(mi.T, c):
    ax.plot(mii + 1e-3 * np.random.randn(len(mii)), color = ci)
# ax.set_yscale("log")
# ax.set_xscale("log")
fig.savefig("test")
fig.show()
#+end_src






[adklfajlkfjj]
for appendix
#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy

from sklearn.preprocessing import minmax_scale
from utils import ccolors
imi = np.stack(ndf.imi)
asy = np.stack(ndf.asymp)
h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

fig, axs = plt.subplots(nrows = 3,
                        ncols = n,
                        share = 1,
                        span = "row",
                        # spany = "row",
                        # height_ratios = [0.5, 1],
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
for ax, axj, axk,  t in zip(axs[0,:], axs[1,:], axs[2, :], targets):
    idx = np.where(mag.round(1) == t)[0][0]
    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")
    p = ndf.p0.iloc[idx]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    ax.set_title(f"{tit:.2f}",)

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    axj.add_artist(lc)
    axj.axis("off")
    axj.axis("equal")
    for node, (ci, x, si) in enumerate(zip(c, pos.values(), s)):
        s = imi[idx]
        s /= s.max()
        ax.scatter(*x, s = s[node]*600, color = ci)

        s = asy[idx]
        s /= s.max()
        axj.scatter(*x, s = s[node]*600, color = ci)
        axk.plot(df.mi.iloc[idx][:, node], color = ci)

axs[0, :].format(fontsize = fs,
                 )

fig.suptitle("System Stability\nFractions of nodes in +1")
axs[0,0].format(
    abc = 1,
    abc_kw = dict(text = "a"))

axs[1,0].format(
    abc = 1,
    abc_kw = dict(text = "b"))

axs[2,0].format(
    abc = 1,
    abc_kw = dict(text = "c"))


axs[2,:].format(xlabel = "Time(t)",
                yscale = "log",
                # xscale = "log",
                fontsize = fs,
                )
yl = "$I(s_i : S^t)$"
axs[2,0].set_ylabel(yl, fontsize = fs)
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]
fig.savefig(f"./figures/{dyn}_kite_graph_appendix.pdf")
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 2113 :height 1563
[[file:./.ob-jupyter/803a2aaf16a414696ac6ec4f97ebb830c80ede88.png]]
:END:


#+begin_src jupyter-python
import matplotlib.pyplot as pplt
import networkx as nx
g = nx.florentine_families_graph()
fig, axs = pplt.subplots(2, 2, sharey = "row", sharex = 'row')
for axi in axs[0, :]:
    nx.draw_forceatlas2(g, ax = axi, node_size = 20)
for idx, axi in enumerate(axs[1, :]):
    axi.plot(np.random.rand(2, 100) + idx)

#+end_src

#+RESULTS:
:RESULTS:
: /home/casper/miniconda3/lib/python3.9/site-packages/networkx-2.6rc1.dev0-py3.9.egg/networkx/drawing/layout.py:1278: RuntimeWarning: invalid value encountered in true_divide
:   factor = (tmp / d2) * scaling
#+attr_org: :width 400 :height 400
[[file:./.ob-jupyter/0f45df024ba68dd1040f6b202c3521e679fbc5f1.png]]
:END:


#+begin_src jupyter-python
nx.adjacency_matrix(g).todense()
#+end_src

#+RESULTS:
: matrix([[0, 1, 1, 1, 0, 1, 0, 0, 0, 0],
:         [1, 0, 0, 1, 1, 0, 1, 0, 0, 0],
:         [1, 0, 0, 1, 0, 1, 0, 0, 0, 0],
:         [1, 1, 1, 0, 1, 1, 1, 0, 0, 0],
:         [0, 1, 0, 1, 0, 0, 1, 0, 0, 0],
:         [1, 0, 1, 1, 0, 0, 1, 1, 0, 0],
:         [0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
:         [0, 0, 0, 0, 0, 1, 1, 0, 1, 0],
:         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
:         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])

#+begin_src jupyter-python
df.columns
#+end_src

#+RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0'], dtype='object')

#+begin_src jupyter-python
print(df.mi)
#+end_src

#+RESULTS:
#+begin_example
0     [[-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0...
1     [[0.010483044738736513, 0.010483044738736513, ...
2     [[0.0030986073155969546, 0.0030986073155969546...
3     [[0.014138328180891141, 0.014138328180891141, ...
4     [[0.39197119061559027, 0.39197119061559027, 0....
5     [[0.9999999999999996, 1.0, 1.0, 1.0, 1.0, 1.0,...
6     [[0.39197119061559027, 0.39197119061559027, 0....
7     [[0.014138328180892556, 0.014138328180892556, ...
8     [[0.0030986073155959, 0.0030986073155959, 0.01...
9     [[0.010483044738736735, 0.010483044738736735, ...
10    [[-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0...
11    [[1.0, 1.0000000000000002, 1.0000000000000002,...
Name: mi, dtype: object
#+end_example


#+begin_src jupyter-python
mi = df.mi.iloc[5]
print(mi.shape)
from utils import ccolors
C = ccolors(10)
fig, ax = plt.subplots()
for ci, mii in zip(C, mi.T):
    ax.plot(mii, color = ci)
ax.set_title(f"T = {1/0.5732374683235916}")
ax.format(xscale = "log")
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: (300, 10)
#+attr_org: :width 288 :height 300
[[file:./.ob-jupyter/28bc713dbab0d1abca8e8e9e1b8dc8eb41ac4167.png]]
:END:

#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
fp='./data/exact_kite_dyn=ising_beta=0.9001444450539172_T=310_g.is_directed()=False.pkl'
fp='./data/exact_kite_dyn=ising_beta=0.9001444450539172_T=310_g.is_directed()=False.pkl'
df = pd.read_pickle(fp)
from utils import ccolors
print(df.mag)
C = ccolors(10)
mi = np.stack(df.mi)
fig, ax = plt.subplots()
I = mi[5].T
for c, mii in zip(C, I):
    ax.plot(mii, color = c, lw = 1)
inax = ax.inset_axes((0.5, 0.5,0.5, 0.5), zoom = 0)
nx.draw(df.attrs["settings"].g, ax = inax,
        node_color = C, node_size = 12)

ax.format(
ylabel = "$I(s_i : M^t)$",
xlabel = 'Time(t)')
fig.show()
fig.savefig("test")
mi.shape
#+end_src


#+begin_src jupyter-python
from utils import ccolors
C = ccolors(10)
print(ndf.columns)
imi = np.stack(ndf.imi)
ai = np.stack(ndf.asymp)
print(imi.shape, ai.shape)

tmp = np.stack((imi, ai))[:, :-1]
# tmp[tmp < 1e-3] = 0

mag = ndf.mag[:-1] - 0.05

fig, ax = plt.subplots(ncols = 2, share = 0, spanx = True)
print(tmp.shape)

# inax = ax[2].inset_axes((0,0,1,1), projection = "3d", zoom = 0)
for node_imi, c in zip(tmp.T, C):
    # node_imi[node_imi < 1e-2] = 0
    ax[0].plot(mag, node_imi[...,0], color = c, marker = 'o', alpha = 1)
    ax[1].plot(mag, node_imi[...,1], color = c, marker = 'o', alpha = 1)

    # inax.plot(mag, node_imi[..., 0], node_imi[..., 1])

    # ax[1].plot[]
xl0 = "Integrated mutual information ($\mu(s_i)$)"
xl1 = "Aymptotic information ($\omega$)"

ax.format(xlabel = r"System macrostate $\langle S \rangle$")
ax[0].set_ylabel(xl0)
ax[1].set_ylabel(xl1)
# ax.format(yscale = "symlog")
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0', 'pst', 'psc', 'coeffs', 'half', 'asymp',
:        'imi', 'rmse'],
:       dtype='object')
: (12, 10) (12, 10)
: (2, 11, 10)
#+attr_org: :width 637 :height 304
[[file:./.ob-jupyter/4a852e7845ec04cdd18e5f4b7d5f2b0badcf17c1.png]]
:END:

#+begin_src jupyter-python
print(tmp.shape)
# fig, ax = plt.subplots()
# for node in range(nodes):
#     ax.plot(*tmp[..., node], color = C[node], marker = 'o')
# ax.format()
# fig.show()

fig, ax = plt.subplots()
ax.imshow(tmp[0].T)
ax.format()
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: (2, 11, 10)
#+attr_org: :width 277 :height 260
[[file:./.ob-jupyter/b11d44d00c23ffd5490858f7199c7a93af808ed6.png]]
:END:


#+begin_src jupyter-python
g = nx.krackhardt_kite_graph()
idx = np.max(tmp, axis = 2)
print(tmp.round(1))
pos = nx.kamada_kawai_layout(g)
l = []
fig, ax = plt.subplots()
D = ccolors(len(mag))
for jdx, magi in enumerate(mag):
    target = np.where(tmp[0, jdx] == idx[0, jdx])[0]
    other = np.where(tmp[1, jdx] == idx[1, jdx])[0]

    print(round(magi, 1), target[0], other[0], end = "\n")
    o = tmp[0, jdx, target[0]]
    oo = tmp[1, jdx, other[0]]
    l.append((o, oo))
    ax.scatter(o, oo, color = C[target[0]])
    # for t, tt in zip(target,  other):
        # ax.scatter(tmp[0, jdx, t], tmp[1, jdx, tt], color = D[jdx], alpha = 1)
l = np.array(l)
# l /= l.max(0)
# l /= l.max(1)[:, None]
ax.plot(*l.T, zorder = 0)
# ax.set_xscale("symlog")
# ax.set_yscale("symlog")
# ax.scatter(*l.T, c = D)
# h = ax.imshow(l.T)
# ax.colorbar(h)
# ax.scatter(*l.T, marker = "o", color = D)
ax.format(xlabel = "IMI ($\mu(s_i)$)",
          ylabel = "AI ($\omega$)")
#+end_src

#+begin_src jupyter-python
from utils import ccolors
print(ndf.columns)
mi = np.stack(ndf.mi)
coeffs = np.stack(ndf.coeffs)
print(mi.shape, coeffs.shape)

x = np.linspace(0, 1100, 5000)
C = ccolors(10)
P  = 5
node = 8
fig, ax = plt.subplots()
for mi_node, c in zip(mi[P].T, C):
    # node[node < 1e-3] = 0
    ax.plot(mi_node, color = c)
ax.plot(x, f(x, *coeffs[P, node]), ls = "dashed", color = C[node])
ax.format(xscale = "log", yscale = "log")
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0', 'coeffs', 'half', 'asymp', 'imi', 'rmse'], dtype='object')
: (12, 2000, 10) (12, 10, 5)
#+attr_org: :width 288 :height 282
[[file:./.ob-jupyter/c5e8e8d5234bdf06bbbac0d48c297ae84d32089e.png]]
:END:


#+begin_src jupyter-python
imi = np.stack(ndf.imi)
ai = np.stack(ndf.asymp)
mi = np.stack(ndf.mi)
from utils import ccolors
C = ccolors(10)
g = nx.krackhardt_kite_graph()
pos = nx.kamada_kawai_layout(g)
mi = np.stack(ndf.mi)
mag = (np.asarray(ndf.mag.copy()) - 0.05).round(1)[:-1]
print(mag)
targets = np.linspace(0.1, 0.5, 5)


layout = [
          [1, 1, 2, 2, 3, 3, 4, 4, 5, 5],
          [6, 6, 6, 6, 6, 7, 7, 7, 7, 7]
]

# layout = [[3, 4, 5, 6, 7],
          # [1, 1, 1, 2, 2]]


fig = plt.figure(share = 0, spanx = 1, refwidth='10cm')
fig, ax = plt.subplots(layout, refnum = 5, share = 0, spanx = 1, refwidth = "10cm")

tmp = np.stack((imi, ai))[:, :-1]

for node_imi, c in zip(tmp.T, C):
    ax[5].plot(mag, node_imi[...,0], color = c, marker = 'o', alpha = 1)
    ax[6].plot(mag, node_imi[...,1], color = c, marker = 'o', alpha = 1)


for target, axi in zip(targets, ax[0, :]):
    idx = np.argmin( abs(mag  - target))
    for c, node in zip(C, mi[idx].T):
        axi.plot(node, color = c)

    title = ""
    # if target == 0.1:
        # title = "Ground state\n"
    if target == 0.5:
        title = "Tipping point\n"
    title += f"$\\langle S\\rangle$ = {round(target, 1)}"
    axi.set_title(title)
    # inax = axi.inset_axes((0.5, 0.4, 0.5, 0.6), zoom = 0)

    s = tmp[0, idx].copy()
    s /= s.max()


    # if target == 0.1:
    #     inax.set_title("Integrated mutual information")

    ymin = tmp[0, idx].min()
    ymax = tmp[0, idx].max()

    y_offset = ymax / tmp[0, :-1].max()
    y_offset = np.clip(y_offset + 0.01, 0, 1)
    y_offset  = 0.75
    b = (target - .15, target + 0.24, 0.25, 0.25)
    inax = ax[5].inset_axes(b, zoom = 1)
    rec, indicators = inax.indicate_inset_zoom()
    [indicator.set_visible(0) for indicator in indicators]
    # indicators[1].set_visible(1)
    # indicators[0].set_visible(1)
    # indicators[2].set_visible(1)
    inax.axis("off")

    xlim = (target - 0.025, target + 0.025)
    ylim = (ymin * 0.90, ymax * 1.10)
    inax.format(xlim = xlim, ylim = ylim)

    inax = ax[5].inset_axes(b, zoom = 0)

    nx.draw_networkx_edges(g, pos, ax = inax, alpha = 0.2)
    l = np.asarray(list(pos.values())).T
    inax.scatter(*l, c = C, s = s*60)
    inax.axis("equal")
    inax.set_facecolor("none")
    inax.grid(0)
    inax.axis('off')
    inax.margins(0)


    s = tmp[1, idx].copy()
    s /= tmp[1].max()

    ymin = tmp[1, idx].min()
    ymax = tmp[1, idx].max()

    y_offset = ymax / tmp[0, :-1].max()
    y_offset = np.clip(y_offset + 0.01, 0, 1)
    y_offset  = 0.75
    b = (target - .15, target + 0.24, 0.25, 0.25)
    inax = ax[6].inset_axes(b, zoom = 1)
    rec, indicators = inax.indicate_inset_zoom()
    [indicator.set_visible(0) for indicator in indicators]
    # indicators[1].set_visible(1)
    # indicators[0].set_visible(1)
    # indicators[2].set_visible(1)
    inax.axis("off")

    xlim = (target - 0.025, target + 0.025)
    ylim = (ymin * 0.90, ymax * 1.10)
    inax.format(xlim = xlim, ylim = ylim)

    inax = ax[6].inset_axes(b, zoom = 0)

    nx.draw_networkx_edges(g, pos, ax = inax, alpha = 0.2)
    l = np.asarray(list(pos.values())).T
    inax.scatter(*l, c = C, s = s.round(3)*60)
    inax.axis("equal")
    inax.set_facecolor("none")
    inax.grid(0)
    inax.axis('off')
    inax.margins(0)



ax[5].set_ylim(-1, 20)
ax[6].set_ylim(-0.05, 0.75)
ax[0, :].format(xlim = (0, 150), xlabel = "Time ($t$)")
ax[0, 0].format(ylabel = "Information flow\n$I(s_i : S^{\\tau + t }| \\langle S^{\\tau} \\rangle)$")
ax.format(fontsize = 21, abc = True, titleabove = False)

ax[6].set_ylabel("Asymptotic information ($\omega$)")
ax[5].set_ylabel("Integrated mutual information\n($\mu(s_i)$)")
ax[1,:].format(xlabel = "System macrostate ($\\langle S \\rangle $)")
fig.suptitle("Fraction of nodes in state +1",
             fontsize = 32)
# fig.savefig("./figures/figure2_alt.pdf")
fig.savefig("test")
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]
: Figure(refwidth=3.94)
#+attr_org: :width 2510 :height 1104
[[file:./.ob-jupyter/216e9d6329388aef130692a4a4f56868f58edc30.png]]
:END:
