#+begin_src jupyter-python
%load_ext autoreload
%autoreload 2
import warnings
warnings.filterwarnings('ignore')
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
from pathlib import Path
import re

base = Path("./data")
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"

# fp = "exact_kite_dyn=bornholdt_beta=0.12568738973509125_T=200.pkl"
# fp = "exact_kite_dyn=bornholdt_beta=0.23708107265108683_T=200.pkl"
fp = "exact_kite_dyn=sis_beta=9.122104355448496_T=200.pkl"
fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=200.pkl"
fp='exact_kite_dyn=ising_beta=0.5732374683235916_T=300_g.is_directed()=False.pkl'
fp='exact_kite_dyn=ising_beta=0.5732374683235916_T=300_g.is_directed()=False.pkl'
# fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=30000.pkl"
# fp = "exact_kite_dyn=ising_beta=0.5732374683235916_T=310.pkl"
# fp='exact_kite_dyn=ising_beta=0.8333333333333334_T=310_g.is_directed()=False.pkl'
# n_samples = int(re.findall("T=\d+", fp)[0].split("=")[1])
# fp='exact_kite_dyn=ising_beta=0.8333333333333334_T=310_g.is_directed()=False.pkl'
# fp='exact_kite_dyn=ising_beta=0.8333333333333334_T=310_g.is_directed()=False.pkl'
# fp='exact_kite_dyn=ising_beta=0.5732374683235916_T=310_g.is_directed()=False.pkl'
# fp='exact_kite_dyn=ising_beta=0.9001444450539172_T=310_g.is_directed()=False.pkl'

# fp = "exact_recursive_tree_4_beta=0.567_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=1_matching=0.7_beta=0.4272728243801874_T=200.pkl"
# fp = "exact_LCF_graph_n=10_shift_list=[-2]_repeat=5_matching=0.9_beta=0.4115334169153415_T=200.pkl"
# fp = "exact_circle_beta=0.567_T=200.pkl"
# fp='./exact_kite_dyn=ising_beta=1_T=310_g.is_directed()=False.pkl'
# fp='./exact_kite_dyn=ising_beta=4_T=310_g.is_directed()=False.pkl'
from exact_utils import fit_curve
df = pd.read_pickle(base / Path(fp))
f = lambda x, a, b, c, d, g: a * np.exp(-b * x) +  c * np.exp(-d * x) + g
# f = lambda x, a, b, c, d, g: a * np.exp(-b * x) +  g
ndf = fit_curve(df, f, offset = True)
#+end_src

#+RESULTS:
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload
: 1.05


#+begin_src jupyter-python
g = ndf.attrs["settings"].g
fig, ax = plt.subplots()
nx.draw(g, pos = nx.kamada_kawai_layout(g), ax = ax)
ax.axis("equal")
ax.format()
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 262 :height 411
[[file:./.ob-jupyter/ec69192c83f389a87e63f6d33a9f3ef3c3c6e5c3.png]]
:END:

#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy

from sklearn.preprocessing import minmax_scale
from utils import ccolors
print(ndf.columns)
imi = np.stack(ndf.imi)
asy = np.stack(ndf.asymp)
mi = np.stack(ndf.mi)

h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]
# targets =  [ 0.0125,  0.1375,  0.2625,  0.3875,  0.5125, 0.6375 ]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

import matplotlib.pyplot as pplt

fig, axs = plt.subplots(nrows = 3,
                        ncols = n,
                        # sharex = 'row',
                        # sharey = 'row',
                        share = 1,
                        span = "row",
                        # height_ratios = [0.5, 1],
                        # figsize = (5,5),
                        # constrained_layout = True
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
tits = []
pos_ = np.array([i for i in pos.values()])
for ax, axj, axk,  t in zip(axs[0,:], axs[1,:], axs[2,:], targets):
    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    axj.add_artist(lc)

    axj.axis("off")
    axj.axis("equal")

    print(t, np.where(mag == t), mag == t, mag)
    idx = np.where(mag.round(2) == round(t, 2))[0][0]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    tits.append(tit)
    # ax.set_title(f"{tit:.2f}",
                 # y = 1.3,
                 # fontsize = 8,
                 # )

    for node, (ci, x) in enumerate(zip(c, pos.values())):
        s = imi[idx]
        s /= s.max()
        ax.scatter(*x, s = s[node]*600, color = ci)

        s = asy[idx]
        s /= s.max()
        axj.scatter(*x, s = s[node]*600, color = ci)

        # axk.scatter(asy[idx], imi[idx], color = c)
        axk.plot(mi[idx, :, node], color = ci)

    # axk.scatter(asy[idx], imi[idx], color = c, s = 500)
    # axk.axis("equal")

# axs.format(fontsize = fs)
# axs.axis('off')
axs[2, :].set_xlabel("Time(t)")
axs[2, :].format(xlim = (0, 100))
# axs[2, :].format(yscale = "log", xscale = "log")
axk.set_ylabel("$I(s_i : S'^t)$")

# axs[2,:].set_xlabel("Asymptotic information")
# axk.set_ylabel("Integrated mutual\ninformation")

fig.suptitle("System Stability\nFractions of nodes in +1",
             fontsize = 24,
             )
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]

axs[0,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "a"))
axs[1,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "b"))
axs[2,0].format(
    abc = 1,
    abcloc = 'l',
    abc_kw = dict(text = "c"))

for idx, t in enumerate(tits):
    axs[0, idx].set_title(round(t,2), y = 0.95)
fig.savefig(f"./figures/{dyn}_kite_graph.pdf")
fig.savefig("./figures/figure2.pdf")
#+end_src
kalsdfjsl
#+RESULTS:
:RESULTS:
#+begin_src jupyter-python
fig, ax = pplt.subplots(ncols = 3)
for axi in ax:
    axi.scatter(*pos_.T, s = np.random.randint(1, 10, size = len(pos))*5)
    axi.axis('equal')
    axi.axis('off')
fig.show()
#+end_src



#+begin_src jupyter-python
dfi = df[df.mag.round(1) == -1]
mi = np.stack(dfi.mi).squeeze()
fig, ax = plt.subplots()
for mii, ci in zip(mi.T, c):
    ax.plot(mii + 1e-3 * np.random.randn(len(mii)), color = ci)
# ax.set_yscale("log")
# ax.set_xscale("log")
fig.savefig("test")
fig.show()
#+end_src






[adklfajlkfjj]
for appendix
#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy

from sklearn.preprocessing import minmax_scale
from utils import ccolors
imi = np.stack(ndf.imi)
asy = np.stack(ndf.asymp)
h = np.stack(ndf.h)
mag = ndf.mag.unique() - 0.05
imi = imi[:-1]
# imi = (imi - imi.min(1)[:, None]) / (imi.max(1)[:, None] - imi.min(1)[:, None])
g = df.attrs["settings"].g

targets = [0.1, 0.2, 0.3, 0.4, 0.5]
pos = nx.kamada_kawai_layout(g)

n = len(targets)

from matplotlib.collections import LineCollection as LC

c = ccolors(len(g))

fig, axs = plt.subplots(nrows = 3,
                        ncols = n,
                        share = 1,
                        span = "row",
                        # spany = "row",
                        # height_ratios = [0.5, 1],
                        )

fs = 32

plot_mag = h[:, 0].sum(-1)
for ax, axj, axk,  t in zip(axs[0,:], axs[1,:], axs[2, :], targets):
    idx = np.where(mag.round(1) == t)[0][0]
    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    ax.add_artist(lc)
    ax.axis("off")
    ax.axis("equal")
    p = ndf.p0.iloc[idx]
    f = mag[idx]
    tit = f# - np.nansum((f * np.log2(f), (1 - f) * np.log2( 1 - f)))
    ax.set_title(f"{tit:.2f}",)

    lc = LC([[pos[x], pos[y]] for x, y in g.edges()], color = 'k', zorder = 0)
    axj.add_artist(lc)
    axj.axis("off")
    axj.axis("equal")
    for node, (ci, x, si) in enumerate(zip(c, pos.values(), s)):
        s = imi[idx]
        s /= s.max()
        ax.scatter(*x, s = s[node]*600, color = ci)

        s = asy[idx]
        s /= s.max()
        axj.scatter(*x, s = s[node]*600, color = ci)
        axk.plot(df.mi.iloc[idx][:, node], color = ci)

axs[0, :].format(fontsize = fs,
                 )

fig.suptitle("System Stability\nFractions of nodes in +1")
axs[0,0].format(
    abc = 1,
    abc_kw = dict(text = "a"))

axs[1,0].format(
    abc = 1,
    abc_kw = dict(text = "b"))

axs[2,0].format(
    abc = 1,
    abc_kw = dict(text = "c"))


axs[2,:].format(xlabel = "Time(t)",
                yscale = "log",
                # xscale = "log",
                fontsize = fs,
                )
yl = "$I(s_i : S^t)$"
axs[2,0].set_ylabel(yl, fontsize = fs)
dyn = re.findall("dyn=[a-z]+", fp)[0].split("=")[1]
fig.savefig(f"./figures/{dyn}_kite_graph_appendix.pdf")
#+end_src

#+RESULTS:
:RESULTS:
#+attr_org: :width 2113 :height 1563
[[file:./.ob-jupyter/803a2aaf16a414696ac6ec4f97ebb830c80ede88.png]]
:END:


#+begin_src jupyter-python
import matplotlib.pyplot as pplt
import networkx as nx
g = nx.florentine_families_graph()
fig, axs = pplt.subplots(2, 2, sharey = "row", sharex = 'row')
for axi in axs[0, :]:
    nx.draw_forceatlas2(g, ax = axi, node_size = 20)
for idx, axi in enumerate(axs[1, :]):
    axi.plot(np.random.rand(2, 100) + idx)

#+end_src

#+RESULTS:
:RESULTS:
: /home/casper/miniconda3/lib/python3.9/site-packages/networkx-2.6rc1.dev0-py3.9.egg/networkx/drawing/layout.py:1278: RuntimeWarning: invalid value encountered in true_divide
:   factor = (tmp / d2) * scaling
#+attr_org: :width 400 :height 400
[[file:./.ob-jupyter/0f45df024ba68dd1040f6b202c3521e679fbc5f1.png]]
:END:


#+begin_src jupyter-python
nx.adjacency_matrix(g).todense()
#+end_src

#+RESULTS:
: matrix([[0, 1, 1, 1, 0, 1, 0, 0, 0, 0],
:         [1, 0, 0, 1, 1, 0, 1, 0, 0, 0],
:         [1, 0, 0, 1, 0, 1, 0, 0, 0, 0],
:         [1, 1, 1, 0, 1, 1, 1, 0, 0, 0],
:         [0, 1, 0, 1, 0, 0, 1, 0, 0, 0],
:         [1, 0, 1, 1, 0, 0, 1, 1, 0, 0],
:         [0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
:         [0, 0, 0, 0, 0, 1, 1, 0, 1, 0],
:         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
:         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])

#+begin_src jupyter-python
df.columns
#+end_src

#+RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0'], dtype='object')

#+begin_src jupyter-python
print(df.mi)
#+end_src

#+RESULTS:
#+begin_example
0     [[-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0...
1     [[0.010483044738736513, 0.010483044738736513, ...
2     [[0.0030986073155969546, 0.0030986073155969546...
3     [[0.014138328180891141, 0.014138328180891141, ...
4     [[0.39197119061559027, 0.39197119061559027, 0....
5     [[0.9999999999999996, 1.0, 1.0, 1.0, 1.0, 1.0,...
6     [[0.39197119061559027, 0.39197119061559027, 0....
7     [[0.014138328180892556, 0.014138328180892556, ...
8     [[0.0030986073155959, 0.0030986073155959, 0.01...
9     [[0.010483044738736735, 0.010483044738736735, ...
10    [[-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0...
11    [[1.0, 1.0000000000000002, 1.0000000000000002,...
Name: mi, dtype: object
#+end_example


#+begin_src jupyter-python
mi = df.mi.iloc[-1]
print(mi.shape)
from utils import ccolors
C = ccolors(10)
fig, ax = plt.subplots()
for ci, mii in zip(C, mi.T):
    ax.plot(mii, color = ci)
ax.set_title(f"T = {1/0.5732374683235916}")
ax.format(xscale = "log")
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: (30000, 10)
#+attr_org: :width 288 :height 300
[[file:./.ob-jupyter/a88944bd5c586af256073e6f29b2b9e4da5237d4.png]]
:END:

#+begin_src jupyter-python
import proplot as plt, cmasher as cmr, pandas as pd,\
    numpy as np, os, sys, networkx as nx, warnings
from plexsim import models
from imi import infcy
fp='./data/exact_kite_dyn=ising_beta=0.9001444450539172_T=310_g.is_directed()=False.pkl'
fp='./data/exact_kite_dyn=ising_beta=0.9001444450539172_T=310_g.is_directed()=False.pkl'
df = pd.read_pickle(fp)
from utils import ccolors
print(df.mag)
C = ccolors(10)
mi = np.stack(df.mi)
fig, ax = plt.subplots()
I = mi[5].T
for c, mii in zip(C, I):
    ax.plot(mii, color = c, lw = 1)
inax = ax.inset_axes((0.5, 0.5,0.5, 0.5), zoom = 0)
nx.draw(df.attrs["settings"].g, ax = inax,
        node_color = C, node_size = 12)

ax.format(
ylabel = "$I(s_i : M^t)$",
xlabel = 'Time(t)')
fig.show()
fig.savefig("test")
mi.shape
#+end_src

#+RESULTS:
:RESULTS:
#+begin_example
0     0.05
1     0.15
2     0.25
3     0.35
4     0.45
5     0.55
6     0.65
7     0.75
8     0.85
9     0.95
10    1.05
11   -1.00
Name: mag, dtype: float64
#+end_example
| 12 | 310 | 10 |
#+attr_org: :width 342 :height 300
[[file:./.ob-jupyter/d34873931d551eb092f36b16aff35dd9074d19c0.png]]
:END:


#+begin_src jupyter-python
from utils import ccolors
C = ccolors(10)
print(ndf.columns)
imi = np.stack(ndf.imi)
ai = np.stack(ndf.asymp)
print(imi.shape, ai.shape)

tmp = np.stack((imi, ai))[:, :-1]
# tmp[tmp < 1e-3] = 0

mag = ndf.mag[:-1]
print(tmp.shape)
fig, ax = plt.subplots()
for node_imi, c in zip(tmp[0].T, C):
    # node_imi[node_imi < 1e-2] = 0
    ax.plot(mag, node_imi, color = c, marker = 'o', alpha = 0.2)
xl = "Integrated mutual information ($\mu(s_i)$)"
ax.format(xlabel = xl, ylabel = "AI")
ax.format(xlabel = r"System macrostate $\langle S \rangle$", ylabel = xl)
# ax.format(yscale = "symlog")
fig.show()
#+end_src

#+RESULTS:
:RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0', 'pst', 'psc', 'coeffs', 'half', 'asymp',
:        'imi', 'rmse'],
:       dtype='object')
: (12, 10) (12, 10)
: (2, 11, 10)
#+attr_org: :width 313 :height 305
[[file:./.ob-jupyter/568c74087bced5bede3c061939bac668a60e7bbe.png]]
:END:


#+begin_src jupyter-python
print(ndf.columns)
mi = np.stack(ndf.mi)
coeffs = np.stack(ndf.coeffs)
print(mi.shape, coeffs.shape)

x = np.linspace(0, 1100, 5000)
C = ccolors(10)
P  = 5
node = 8
fig, ax = plt.subplots()
for mi_node, c in zip(mi[P].T, C):
    # node[node < 1e-3] = 0
    ax.plot(mi_node, color = c)
ax.plot(x, f(x, *coeffs[P, node]), ls = "dashed", color = C[node])
ax.format(xscale = "log", yscale = "log")
fig.show()

#+end_src

#+RESULTS:
:RESULTS:
: Index(['mi', 'h', 'hc', 'mag', 'p0', 'pst', 'psc', 'coeffs', 'half', 'asymp',
:        'imi', 'rmse'],
:       dtype='object')
: (12, 300, 10) (12, 10, 5)
#+attr_org: :width 306 :height 282
[[file:./.ob-jupyter/343d7f57f25d78de305cc261b9e502627d01c7eb.png]]
:END:
